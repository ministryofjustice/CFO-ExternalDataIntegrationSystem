name: Reusable Deploy

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
        description: 'Environment name (preprod or prod)'
      aws-region:
        required: false
        type: string
        default: 'eu-west-2'
    secrets:
      AWS_ROLE_ARN:
        required: true
      AWS_SECRETS_ARN:
        required: true
  workflow_dispatch:
    inputs:
      environment:
        required: true
        type: choice
        description: 'Environment to deploy to'
        options:
          - preprod
          - prod
      aws-region:
        required: false
        type: string
        default: 'eu-west-2'
        description: 'AWS region'

permissions:
  id-token: write
  contents: read

jobs:
  load-services:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.load.outputs.services }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      
      - name: Load service mappings
        id: load
        run: |
          services=$(jq -c '.services' infra/services.json)
          echo "services=${services}" >> $GITHUB_OUTPUT
          echo "Loaded services:"
          echo "${services}" | jq '.'

  deploy:
    needs: load-services
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    
    strategy:
      matrix:
        service: ${{ fromJson(needs.load-services.outputs.services) }}
      fail-fast: false
    
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ inputs.aws-region }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Fetch IAM Role ARNs from Secrets Manager
        id: fetch-roles
        run: |
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id ${{ secrets.AWS_SECRETS_ARN }} \
            --query 'SecretString' \
            --output text)
          
          TASK_ROLE=$(echo "$SECRET_JSON" | jq -r '.Task_Role_ARN')
          EXEC_ROLE=$(echo "$SECRET_JSON" | jq -r '.Execution_Role_ARN')
          
          # Mask secrets in logs
          echo "::add-mask::$TASK_ROLE"
          echo "::add-mask::$EXEC_ROLE"
          
          echo "task-role=${TASK_ROLE}" >> $GITHUB_OUTPUT
          echo "exec-role=${EXEC_ROLE}" >> $GITHUB_OUTPUT

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: 10.0.x

      - name: Run tests
        run: dotnet test --configuration Release

      - name: Build and Publish Image
        id: build-image
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          REPOSITORY: ${{ inputs.environment }}/${{ matrix.service.name }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          PROJECT_PATH="src/${{ matrix.service.project }}"
          
          if [ ! -f "$PROJECT_PATH" ]; then
            echo "Project not found: $PROJECT_PATH - Skipping"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Building and publishing: $PROJECT_PATH"
          
          dotnet publish "$PROJECT_PATH" \
            --configuration Release \
            --target:PublishContainer \
            --property:ContainerRegistry=$REGISTRY \
            --property:ContainerRepository=$REPOSITORY \
            --property:ContainerImageTag=$IMAGE_TAG
          
          IMAGE="${REGISTRY}/${REPOSITORY}:${IMAGE_TAG}"
          echo "IMAGE=${IMAGE}" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT
          echo "Published image: ${IMAGE}"

      - name: Build secrets list for service
        id: build-secrets
        run: |
          # Get the secrets array for this service from services.json
          SECRETS_JSON='${{ toJson(matrix.service.secrets) }}'
          
          # Build the secrets string dynamically
          SECRETS_STRING=""
          
          # Map of secret keys to their connection string names
          declare -A SECRET_MAP=(
            ["API_Base_URL"]="API__BaseUrl"
            ["Authentication_ApiKey"]="Authentication__ApiKey"
            ["S3_BucketName"]="AWS__S3__BucketName"
            ["Client_ID"]="AzureAd__ClientId"
            ["Client_Secret"]="AzureAd__ClientSecret"
            ["AuditDb"]="ConnectionStrings__AuditDb"
            ["ClusterDb"]="ConnectionStrings__ClusterDb"
            ["DeliusRunningPictureDb"]="ConnectionStrings__DeliusRunningPictureDb"
            ["DeliusStagingDb"]="ConnectionStrings__DeliusStagingDb"
            ["MatchingDb"]="ConnectionStrings__MatchingDb"
            ["OfflocRunningPictureDb"]="ConnectionStrings__OfflocRunningPictureDb"
            ["OfflocStagingDb"]="ConnectionStrings__OfflocStagingDb"
            ["CatsRabbitMQ"]="ConnectionStrings__CatsRabbitMQ"
            ["RabbitMQ"]="ConnectionStrings__RabbitMQ"
            ["DMSFilesBasePath"]="DMSFilesBasePath"
            ["Sentry_Dsn"]="Sentry_Dsn"
          )
          
          # Parse JSON array and build secrets string
          for secret in $(echo "$SECRETS_JSON" | jq -r '.[]'); do
            env_var_name="${SECRET_MAP[$secret]}"
            if [ -n "$env_var_name" ]; then
              SECRETS_STRING+="${env_var_name}=\${{ secrets.AWS_SECRETS_ARN }}:${secret}::"$'\n'
            fi
          done
          
          # Remove trailing newline and save
          SECRETS_STRING=$(echo "$SECRETS_STRING" | sed '/^$/d')
          echo "secrets<<EOF" >> $GITHUB_OUTPUT
          echo "$SECRETS_STRING" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Render ECS task definition
        if: steps.build-image.outputs.skip != 'true'
        id: render-task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1.8.1
        with:
          task-definition: ${{ matrix.service.taskDef }}
          container-name: ${{ matrix.service.container }}
          image: ${{ steps.build-image.outputs.image }}
          task-role-arn: ${{ steps.fetch-roles.outputs.task-role }}
          execution-role-arn: ${{ steps.fetch-roles.outputs.exec-role }}
          environment-variables: |
            DOTNET_ENVIRONMENT=${{ inputs.environment == 'prod' && 'Production' || 'PreProduction' }}
          secrets: ${{ steps.build-secrets.outputs.secrets }}

            

      - name: Deploy ECS service
        if: steps.build-image.outputs.skip != 'true'
        uses: aws-actions/amazon-ecs-deploy-task-definition@v2
        with:
          task-definition: ${{ steps.render-task-def.outputs.task-definition }}
          service: ${{ matrix.service.name }}-service-1
          cluster: ${{ matrix.service.name }}-cluster
          wait-for-service-stability: true
